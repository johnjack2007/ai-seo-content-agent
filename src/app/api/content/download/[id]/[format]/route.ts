import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { WordExportService } from '@/services/WordExportService';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string; format: string } }
) {
  try {
    const { id, format } = params;
    
    if (!['markdown', 'html', 'word'].includes(format)) {
      return NextResponse.json(
        { error: 'Invalid format. Use "markdown", "html", or "word"' },
        { status: 400 }
      );
    }

    // Fetch the content draft
    let draft;
    if (id.startsWith('local-')) {
      // Handle local drafts (not in database) - create simple content for demo
      draft = {
        id: id,
        title: 'Generated Content',
        content: {
          body: 'This is a demo content generated by the AI SEO Content Agent. The full content would be available here in a production environment.',
          meta_description: 'Demo content for AI SEO Content Agent'
        },
        topic: 'Demo Topic',
        keywords: ['demo', 'content', 'ai']
      };
    } else {
      const { data, error } = await supabase
        .from('content_drafts')
        .select('*')
        .eq('id', id)
        .single();

      if (error || !data) {
        return NextResponse.json(
          { error: 'Content not found' },
          { status: 404 }
        );
      }
      
      draft = data;
    }

    // Get the content (prefer humanized, fallback to original)
    const content = typeof draft.content === 'string' ? draft.content : draft.content?.body || '';
    const title = draft.title || 'Untitled';
    const topic = draft.topic || '';
    const keywords = draft.content?.keywords || draft.keywords || [topic];
    const metaDescription = typeof draft.content === 'object' ? draft.content.meta_description : '';

    let fileContent: string | Buffer = '';
    let mimeType = '';
    let extension = '';

    if (format === 'markdown') {
      fileContent = `# ${title}\n\n${content}\n\n---\n\n*Generated for topic: ${topic}*`;
      mimeType = 'text/markdown';
      extension = 'md';
    } else if (format === 'html') {
      fileContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; margin-top: 30px; }
        h3 { color: #7f8c8d; }
        p { margin-bottom: 16px; }
        .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #ecf0f1; font-size: 0.9em; color: #7f8c8d; }
    </style>
</head>
<body>
    <article>
        <h1>${title}</h1>
        <div>${content.replace(/\n/g, '<br>')}</div>
        <div class="footer">
            <p><em>Generated for topic: ${topic}</em></p>
        </div>
    </article>
</body>
</html>`;
      mimeType = 'text/html';
      extension = 'html';
    } else if (format === 'word') {
      // Generate Word document
      fileContent = await WordExportService.exportToWord({
        title,
        content,
        author: 'AI SEO Content Agent',
        keywords,
        metaDescription
      });
      mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
      extension = 'docx';
    }

    // Generate filename
    const filename = format === 'word' 
      ? WordExportService.generateFilename(title)
      : `${title.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').substring(0, 50)}-${new Date().toISOString().split('T')[0]}.${extension}`;

    // Return the file as a download
    return new NextResponse(fileContent, {
      headers: {
        'Content-Type': mimeType,
        'Content-Disposition': `attachment; filename="${filename}"`,
      },
    });

  } catch (error) {
    console.error('Download failed:', error);
    return NextResponse.json(
      { error: 'Download failed: ' + (error as Error).message },
      { status: 500 }
    );
  }
} 